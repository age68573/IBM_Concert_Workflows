name: Linux_Keystore_Cert_Discovery
platform: node
blocks:
  - action: if
    name: EnvNameCheck
    condition: '!$env_name'
    then:
      - action: throw
        error: "' \"400 Bad Request\" \\n {\"error\": \"Missing required field: env_name\"\
          }'"
    else:
      - action: comment
        value: Getting the keystore password and keystore path from config data.
      - action: system/Common/Config Data/Get Config Data
        name: GetPasswordMap
        inputs:
          - name: authKey
            value: $passwordMap
      - action: assign
        name: GetkeystorePass
        variable: $keystorePass
        value: "$GetPasswordMap.result[$keystorePath] || \"\""
      - name: Function_1
        function: |-
          if (!$keystorePath) {
            throw new Error(' "400 Bad Request" \n {"error": "Missing required field: Keystore path"}');
          }else if(!$keystorePass) {
            throw new Error(' "400 Bad Request" \n {"error": "Password not found for keystore_path"}');
          }
      - action: comment
        value: Ansible script to get certificates from given keystore
      - action: system/Ansible/Playbook
        name: GetCerts
        inputs:
          - name: authKey
            value: $linuxAuth
          - name: playbook
            value: |-
              `---
              - name: Manage Tomcat Installation and Upgrade
                hosts: canary
                become: yes
                vars:
                  keystore_pass: ${JSON.stringify($keystorePass)}
                  keystore: ${JSON.stringify($keystorePath)}
                tasks:

                  - name: Get certificate info for all certs from keystore
                    ansible.builtin.shell: |
                      keytool -list -v -keystore "{{ keystore }}" -storepass "{{ keystore_pass }}"
                    register: keystore_cert_details
                    ignore_errors: true

                  - name: Exit play if keystore password is incorrect
                    ansible.builtin.meta: end_play
                    when: >
                      'keystore password was incorrect' in keystore_cert_details.stdout | lower or
                      'unrecoverablekeyexception' in keystore_cert_details.stdout | lower or
                      'badpaddingexception' in keystore_cert_details.stdout | lower or
                      keystore_cert_details.rc != 0

                  - name: Parse certificate details into clean JSON
                    set_fact:
                      certificates_json: >-
                        {% set certs = [] %}
                        {% set keystore_path_local = keystore %}
                        {% set current_cert = {} %}
                        {% for line in keystore_cert_details.stdout_lines %}
                          {% if "Alias name:" in line %}
                            {% if current_cert %}{% set _ = certs.append(current_cert.copy()) %}{% endif %}
                            {% set _ = current_cert.update({
                              "alias": line.split(":", 1)[1]|trim,
                              "subject": "",
                              "issuer": "",
                              "validFrom": "",
                              "validTo": "",
                              "sha1Thumbprint": "",
                              "sha256Thumbprint": "",
                              "serialNumber": "",
                              "dnsNames": [],
                              "additional_data": {
                                  "keystore_path": keystore_path_local
                                }
                            }) %}
                          {% elif "Owner:" in line %}
                            {% set _ = current_cert.update({"subject": line.split(":", 1)[1]|trim}) %}
                          {% elif "Issuer:" in line %}
                            {% set _ = current_cert.update({"issuer": line.split(":", 1)[1]|trim}) %}
                          {% elif "Serial number:" in line %}
                            {% set _ = current_cert.update({"serialNumber": line.split(":", 1)[1]|trim}) %}
                          {% elif "Valid from:" in line %}
                            {% set parts = line.split("until:") %}
                            {% set _ = current_cert.update({
                              "validFrom": parts[0].split(":", 1)[1]|trim,
                              "validTo": parts[1]|trim if parts|length > 1 else ""
                            }) %}
                          {% elif "SHA1:" in line %}
                            {% set _ = current_cert.update({"sha1Thumbprint": line.split("SHA1:", 1)[1]|trim}) %}
                          {% elif "SHA256:" in line %}
                            {% set _ = current_cert.update({"sha256Thumbprint": line.split("SHA256:", 1)[1]|trim}) %}
                          {% elif "*******************************************" in line and current_cert %}
                            {% set _ = certs.append(current_cert.copy()) %}
                            {% set _ = current_cert.clear() %}
                          {% endif %}
                        {% endfor %}
                        {% if current_cert %}{% set _ = certs.append(current_cert.copy()) %}{% endif %}
                        {{ certs | to_json }}

                  - name: Print parsed certificate JSON
                    debug:
                      var: certificates_json
                      verbosity: 0

                  - name: Save clean JSON to variable
                    set_fact:
                      clean_json: "{{ certificates_json | from_json | to_nice_json }}"

                  - name: Display properly formatted JSON
                    debug:
                      msg: "{{ clean_json }}"
                    when: clean_json is defined

                  - name: Print the OS type
                    debug:
                      msg: "This host is running {{ ansible_os_family }}"

              `
      - action: comment
        value: Get certificates from the result
      - action: assign
        name: Assign_1
        variable: $test1
        value: $GetCerts
      - name: Function_2
        function: |-
          if ($GetCerts.result.plays[0].tasks.length < 4) {
            throw new Error(' "400 Bad Request" \n {"error": "Incorrect keystore password"}');
          }
      - action: assign
        name: AnsibleResult
        variable: $ansibleResult
        value: "$GetCerts.result[\"plays\"][0][\"tasks\"][6][\"hosts\"]"
      - action: assign
        name: AssignServerValue
        variable: $apiserver
        value: "Object.keys($ansibleResult)[0]"
      - action: assign
        name: GetCertificates
        variable: $certs
        value: "$ansibleResult[$apiserver][\"msg\"]"
      - name: ParseCerts
        function: $certificatesJson = JSON.parse($certs)
      - action: comment
        value: Call helper workflows to create and ingest certificates into Concert.
      - action: ./Create_JSON_of_Certificate
        name: IngestHelper
        inputs:
          - name: certificates
            value: $certificatesJson
          - name: concert_auth
            value: $concertAuth
          - name: env_name
            value: $env_name
          - name: api_server
            value: $apiserver
      - action: assign
        name: IngestionResult
        variable: $result
        value: $IngestHelper.result
variables:
  - name: ansibleResult
    required: false
    isInput: false
    isOutput: false
    level: INTERMEDIATE
    type:
      type: any
    value: '""'
  - name: keystorePath
    required: true
    isInput: true
    isOutput: false
    level: INTERMEDIATE
    type:
      type: string
    value: '"/opt/crt/tomcat.jks"'
  - name: keystorePass
    required: false
    isInput: false
    isOutput: false
    level: INTERMEDIATE
    type:
      type: string
    value: '"P@ssw0rd"'
  - name: certificatesJson
    required: false
    isInput: false
    isOutput: false
    level: INTERMEDIATE
    type:
      type: array
    value: "[]"
  - name: env_name
    required: true
    isInput: true
    isOutput: false
    level: INTERMEDIATE
    type:
      type: string
    value: '"jeremy-tomcat.palsys.com.tw"'
  - name: result
    required: false
    isInput: false
    isOutput: true
    level: INTERMEDIATE
    type:
      type: string
    value: '""'
  - name: linuxAuth
    required: true
    isInput: true
    isOutput: false
    level: INTERMEDIATE
    type:
      type: string
    value: '"ibmconcert/Ansible"'
    meta:
      authType: ANY
      subType: authentication
  - name: concertAuth
    required: true
    isInput: true
    isOutput: false
    level: INTERMEDIATE
    type:
      type: string
    value: '"ibmconcert/Hub"'
    meta:
      authType: ANY
      subType: authentication
  - name: certs
    required: false
    isInput: false
    isOutput: false
    level: INTERMEDIATE
    type:
      type: string
    value: '""'
  - name: apiserver
    required: false
    isInput: false
    isOutput: false
    level: INTERMEDIATE
    type:
      type: string
    value: '""'
  - name: passwordMap
    required: true
    isInput: true
    isOutput: false
    level: INTERMEDIATE
    type:
      type: string
    value: '"Tomcat_Config_Data"'
    meta:
      authType: ANY
      subType: authentication
  - name: test1
    required: false
    isInput: false
    isOutput: true
    level: INTERMEDIATE
    type:
      type: string
    value: '""'
meta:
  workerGroup: default
  description: This workflow gets connection to windows machine and fetch all certificates
    present in given keystore. It then ingests the certificates fetched into Concert.
  layout: flow
  version: 5
  tags:
    - name: Consumer
      value: Concert
    - name: Category
      value: Certificates
finally: null
